{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\nimport React, { useState, useEffect, useRef } from 'react';\nimport Text from \"react-native-web/dist/exports/Text\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Button from \"react-native-web/dist/exports/Button\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nNotifications.setNotificationHandler({\n  handleNotification: function handleNotification() {\n    return _regeneratorRuntime.async(function handleNotification$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", {\n              shouldShowAlert: true,\n              shouldPlaySound: false,\n              shouldSetBadge: false\n            });\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n});\nexport function Notification() {\n  var _useState = useState(''),\n      _useState2 = _slicedToArray(_useState, 2),\n      expoPushToken = _useState2[0],\n      setExpoPushToken = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      notification = _useState4[0],\n      setNotification = _useState4[1];\n\n  var notificationListener = useRef();\n  var responseListener = useRef();\n  useEffect(function () {\n    registerForPushNotificationsAsync().then(function (token) {\n      return setExpoPushToken(token);\n    });\n    notificationListener.current = Notifications.addNotificationReceivedListener(function (notification) {\n      setNotification(notification);\n    });\n    responseListener.current = Notifications.addNotificationResponseReceivedListener(function (response) {\n      console.log(response);\n    });\n    return function () {\n      Notifications.removeNotificationSubscription(notificationListener.current);\n      Notifications.removeNotificationSubscription(responseListener.current);\n    };\n  }, []);\n\n  function sendPushNotification(expoPushToken) {\n    var message;\n    return _regeneratorRuntime.async(function sendPushNotification$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            message = {\n              to: expoPushToken,\n              sound: 'default',\n              title: 'Your break is over',\n              body: 'Time to get back to work!',\n              data: {\n                someData: 'goes here'\n              }\n            };\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(fetch('https://exp.host/--/api/v2/push/send', {\n              method: 'POST',\n              headers: {\n                Accept: 'application/json',\n                'Accept-encoding': 'gzip, deflate',\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify(message)\n            }));\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n\n  function registerForPushNotificationsAsync() {\n    var token, _await$Notifications$, existingStatus, finalStatus, _await$Notifications$2, status;\n\n    return _regeneratorRuntime.async(function registerForPushNotificationsAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!Constants.isDevice) {\n              _context3.next = 21;\n              break;\n            }\n\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(Notifications.getPermissionsAsync());\n\n          case 3:\n            _await$Notifications$ = _context3.sent;\n            existingStatus = _await$Notifications$.status;\n            finalStatus = existingStatus;\n\n            if (!(existingStatus !== 'granted')) {\n              _context3.next = 12;\n              break;\n            }\n\n            _context3.next = 9;\n            return _regeneratorRuntime.awrap(Notifications.requestPermissionsAsync());\n\n          case 9:\n            _await$Notifications$2 = _context3.sent;\n            status = _await$Notifications$2.status;\n            finalStatus = status;\n\n          case 12:\n            if (!(finalStatus !== 'granted')) {\n              _context3.next = 15;\n              break;\n            }\n\n            alert('Failed to get push token for push notification!');\n            return _context3.abrupt(\"return\");\n\n          case 15:\n            _context3.next = 17;\n            return _regeneratorRuntime.awrap(Notifications.getExpoPushTokenAsync());\n\n          case 17:\n            token = _context3.sent.data;\n            console.log(token);\n            _context3.next = 22;\n            break;\n\n          case 21:\n            alert('Must use physical device for Push Notifications');\n\n          case 22:\n            if (Platform.OS === 'android') {\n              Notifications.setNotificationChannelAsync('default', {\n                name: 'default',\n                importance: Notifications.AndroidImportance.MAX,\n                vibrationPattern: [0, 250, 250, 250],\n                lightColor: '#FF231F7C'\n              });\n            }\n\n            return _context3.abrupt(\"return\", token);\n\n          case 24:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n}","map":{"version":3,"sources":["/Users/kylecash/Documents/GitHub/BreakTime/src/utils/Notification.js"],"names":["Constants","Notifications","React","useState","useEffect","useRef","setNotificationHandler","handleNotification","shouldShowAlert","shouldPlaySound","shouldSetBadge","Notification","expoPushToken","setExpoPushToken","notification","setNotification","notificationListener","responseListener","registerForPushNotificationsAsync","then","token","current","addNotificationReceivedListener","addNotificationResponseReceivedListener","response","console","log","removeNotificationSubscription","sendPushNotification","message","to","sound","title","body","data","someData","fetch","method","headers","Accept","JSON","stringify","isDevice","getPermissionsAsync","existingStatus","status","finalStatus","requestPermissionsAsync","alert","getExpoPushTokenAsync","Platform","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor"],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Text, View, Button, Platform } from 'react-native';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\nexport function Notification() {\n  const [expoPushToken, setExpoPushToken] = useState('');\n  const [notification, setNotification] = useState(false);\n  const notificationListener = useRef();\n  const responseListener = useRef();\n\n  useEffect(() => {\n    registerForPushNotificationsAsync().then(token => setExpoPushToken(token));\n\n    // This listener is fired whenever a notification is received while the app is foregrounded\n    notificationListener.current = Notifications.addNotificationReceivedListener(notification => {\n      setNotification(notification);\n    });\n\n    // This listener is fired whenever a user taps on or interacts with a notification (works when app is foregrounded, backgrounded, or killed)\n    responseListener.current = Notifications.addNotificationResponseReceivedListener(response => {\n      console.log(response);\n    });\n\n    return () => {\n      Notifications.removeNotificationSubscription(notificationListener.current);\n      Notifications.removeNotificationSubscription(responseListener.current);\n    };\n  }, []);\n\n  // Can use this function below, OR use Expo's Push Notification Tool-> https://expo.dev/notifications\nasync function sendPushNotification(expoPushToken) {\n    const message = {\n      to: expoPushToken,\n      sound: 'default',\n      title: 'Your break is over',\n      body: 'Time to get back to work!',\n      data: { someData: 'goes here' },\n    };\n  \n    await fetch('https://exp.host/--/api/v2/push/send', {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Accept-encoding': 'gzip, deflate',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(message),\n    });\n  }\n  \n  async function registerForPushNotificationsAsync() {\n    let token;\n    if (Constants.isDevice) {\n      const { status: existingStatus } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n      if (existingStatus !== 'granted') {\n        const { status } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n      if (finalStatus !== 'granted') {\n        alert('Failed to get push token for push notification!');\n        return;\n      }\n      token = (await Notifications.getExpoPushTokenAsync()).data;\n      console.log(token);\n    } else {\n      alert('Must use physical device for Push Notifications');\n    }\n  \n    if (Platform.OS === 'android') {\n      Notifications.setNotificationChannelAsync('default', {\n        name: 'default',\n        importance: Notifications.AndroidImportance.MAX,\n        vibrationPattern: [0, 250, 250, 250],\n        lightColor: '#FF231F7C',\n      });\n    }\n  \n    return token;\n  }\n}"]},"metadata":{},"sourceType":"module"}