{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { Platform } from '@unimodules/core';\nimport { PermissionStatus } from 'expo-modules-core';\n\nfunction convertPermissionStatus(status) {\n  switch (status) {\n    case 'granted':\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: true\n      };\n\n    case 'denied':\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: false\n      };\n\n    default:\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false\n      };\n  }\n}\n\nfunction resolvePermissionAsync(_ref) {\n  var _navigator, _navigator$permission;\n\n  var shouldAsk, _window, _window$Notification, Notification, status, query;\n\n  return _regeneratorRuntime.async(function resolvePermissionAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          shouldAsk = _ref.shouldAsk;\n\n          if (Platform.isDOMAvailable) {\n            _context.next = 3;\n            break;\n          }\n\n          return _context.abrupt(\"return\", convertPermissionStatus('denied'));\n\n        case 3:\n          _window = window, _window$Notification = _window.Notification, Notification = _window$Notification === void 0 ? {} : _window$Notification;\n\n          if (!(typeof Notification.requestPermission !== 'undefined')) {\n            _context.next = 13;\n            break;\n          }\n\n          status = Notification.permission;\n\n          if (!shouldAsk) {\n            _context.next = 10;\n            break;\n          }\n\n          _context.next = 9;\n          return _regeneratorRuntime.awrap(new Promise(function (resolve, reject) {\n            var _Notification$request, _Notification$request2;\n\n            var resolved = false;\n\n            function resolveOnce(status) {\n              if (!resolved) {\n                resolved = true;\n                resolve(status);\n              }\n            }\n\n            (_Notification$request = Notification.requestPermission(resolveOnce)) == null ? void 0 : (_Notification$request2 = _Notification$request.then(resolveOnce)) == null ? void 0 : _Notification$request2.catch(reject);\n          }));\n\n        case 9:\n          status = _context.sent;\n\n        case 10:\n          return _context.abrupt(\"return\", convertPermissionStatus(status));\n\n        case 13:\n          if (!(typeof navigator !== 'undefined' && (_navigator = navigator) != null && (_navigator$permission = _navigator.permissions) != null && _navigator$permission.query)) {\n            _context.next = 18;\n            break;\n          }\n\n          _context.next = 16;\n          return _regeneratorRuntime.awrap(navigator.permissions.query({\n            name: 'notifications'\n          }));\n\n        case 16:\n          query = _context.sent;\n          return _context.abrupt(\"return\", convertPermissionStatus(query.state));\n\n        case 18:\n          return _context.abrupt(\"return\", convertPermissionStatus('denied'));\n\n        case 19:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexport default {\n  addListener: function addListener() {},\n  removeListeners: function removeListeners() {},\n  getPermissionsAsync: function getPermissionsAsync() {\n    return _regeneratorRuntime.async(function getPermissionsAsync$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", resolvePermissionAsync({\n              shouldAsk: false\n            }));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  requestPermissionsAsync: function requestPermissionsAsync(request) {\n    return _regeneratorRuntime.async(function requestPermissionsAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", resolvePermissionAsync({\n              shouldAsk: true\n            }));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/NotificationPermissionsModule.ts"],"names":[],"mappings":";AAAA,SAAS,QAAT,QAAyB,kBAAzB;AACA,SAAS,gBAAT,QAAiC,mBAAjC;;AAQA,SAAS,uBAAT,CACE,MADF,EAC4C;AAE1C,UAAQ,MAAR;AACE,SAAK,SAAL;AACE,aAAO;AACL,QAAA,MAAM,EAAE,gBAAgB,CAAC,OADpB;AAEL,QAAA,OAAO,EAAE,OAFJ;AAGL,QAAA,WAAW,EAAE,KAHR;AAIL,QAAA,OAAO,EAAE;AAJJ,OAAP;;AAMF,SAAK,QAAL;AACE,aAAO;AACL,QAAA,MAAM,EAAE,gBAAgB,CAAC,MADpB;AAEL,QAAA,OAAO,EAAE,OAFJ;AAGL,QAAA,WAAW,EAAE,KAHR;AAIL,QAAA,OAAO,EAAE;AAJJ,OAAP;;AAMF;AACE,aAAO;AACL,QAAA,MAAM,EAAE,gBAAgB,CAAC,YADpB;AAEL,QAAA,OAAO,EAAE,OAFJ;AAGL,QAAA,WAAW,EAAE,IAHR;AAIL,QAAA,OAAO,EAAE;AAJJ,OAAP;AAhBJ;AAuBD;;AAED,SAAe,sBAAf;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACE,UAAA,SADF,QACE,SADF;;AAAA,cAKO,QAAQ,CAAC,cALhB;AAAA;AAAA;AAAA;;AAAA,2CAMW,uBAAuB,CAAC,QAAD,CANlC;;AAAA;AAAA,oBASgC,MAThC,iCASU,YATV,EASU,YATV,qCASyB,EATzB;;AAAA,gBAUM,OAAO,YAAY,CAAC,iBAApB,KAA0C,WAVhD;AAAA;AAAA;AAAA;;AAWQ,UAAA,MAXR,GAWiB,YAAY,CAAC,UAX9B;;AAAA,eAYQ,SAZR;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAaqB,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AAAA;;AAC7C,gBAAI,QAAQ,GAAG,KAAf;;AACA,qBAAS,WAAT,CAAqB,MAArB,EAAmC;AACjC,kBAAI,CAAC,QAAL,EAAe;AACb,gBAAA,QAAQ,GAAG,IAAX;AACA,gBAAA,OAAO,CAAC,MAAD,CAAP;AACD;AACF;;AAED,qCAAA,YAAY,CAAC,iBAAb,CAA+B,WAA/B,sEACI,IADJ,CACS,WADT,6CAEI,KAFJ,CAEU,MAFV;AAGD,WAZc,CAbrB;;AAAA;AAaM,UAAA,MAbN;;AAAA;AAAA,2CA2BW,uBAAuB,CAAC,MAAD,CA3BlC;;AAAA;AAAA,gBA4Ba,OAAO,SAAP,KAAqB,WAArB,kBAAoC,SAApC,sCAAoC,WAAW,WAA/C,aAAoC,sBAAwB,KA5BzE;AAAA;AAAA;AAAA;;AAAA;AAAA,2CA8BwB,SAAS,CAAC,WAAV,CAAsB,KAAtB,CAA4B;AAAE,YAAA,IAAI,EAAE;AAAR,WAA5B,CA9BxB;;AAAA;AA8BU,UAAA,KA9BV;AAAA,2CA+BW,uBAAuB,CAAC,KAAK,CAAC,KAAP,CA/BlC;;AAAA;AAAA,2CAkCS,uBAAuB,CAAC,QAAD,CAlChC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqCA,eAAe;AACb,EAAA,WAAW,EAAE,uBAAK,CAAG,CADR;AAEb,EAAA,eAAe,EAAE,2BAAK,CAAG,CAFZ;AAGP,EAAA,mBAHO;AAAA;AAAA;AAAA;AAAA;AAAA,8CAIJ,sBAAsB,CAAC;AAAE,cAAA,SAAS,EAAE;AAAb,aAAD,CAJlB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMP,EAAA,uBANO,mCAOX,OAPW;AAAA;AAAA;AAAA;AAAA;AAAA,8CASJ,sBAAsB,CAAC;AAAE,cAAA,SAAS,EAAE;AAAb,aAAD,CATlB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAf","sourcesContent":["import { Platform } from '@unimodules/core';\nimport { PermissionStatus } from 'expo-modules-core';\n\nimport {\n  NativeNotificationPermissionsRequest,\n  NotificationPermissionsStatus,\n} from './NotificationPermissions.types';\nimport { NotificationPermissionsModule } from './NotificationPermissionsModule.types';\n\nfunction convertPermissionStatus(\n  status?: NotificationPermission | 'prompt'\n): NotificationPermissionsStatus {\n  switch (status) {\n    case 'granted':\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: true,\n      };\n    case 'denied':\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: false,\n      };\n    default:\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n  }\n}\n\nasync function resolvePermissionAsync({\n  shouldAsk,\n}: {\n  shouldAsk: boolean;\n}): Promise<NotificationPermissionsStatus> {\n  if (!Platform.isDOMAvailable) {\n    return convertPermissionStatus('denied');\n  }\n\n  const { Notification = {} } = window as any;\n  if (typeof Notification.requestPermission !== 'undefined') {\n    let status = Notification.permission;\n    if (shouldAsk) {\n      status = await new Promise((resolve, reject) => {\n        let resolved = false;\n        function resolveOnce(status: string) {\n          if (!resolved) {\n            resolved = true;\n            resolve(status);\n          }\n        }\n        // Some browsers require a callback argument and some return a Promise\n        Notification.requestPermission(resolveOnce)\n          ?.then(resolveOnce)\n          ?.catch(reject);\n      });\n    }\n    return convertPermissionStatus(status);\n  } else if (typeof navigator !== 'undefined' && navigator?.permissions?.query) {\n    // TODO(Bacon): Support `push` in the future when it's stable.\n    const query = await navigator.permissions.query({ name: 'notifications' });\n    return convertPermissionStatus(query.state);\n  }\n  // Platforms like iOS Safari don't support Notifications so return denied.\n  return convertPermissionStatus('denied');\n}\n\nexport default {\n  addListener: () => {},\n  removeListeners: () => {},\n  async getPermissionsAsync(): Promise<NotificationPermissionsStatus> {\n    return resolvePermissionAsync({ shouldAsk: false });\n  },\n  async requestPermissionsAsync(\n    request: NativeNotificationPermissionsRequest\n  ): Promise<NotificationPermissionsStatus> {\n    return resolvePermissionAsync({ shouldAsk: true });\n  },\n} as NotificationPermissionsModule;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}