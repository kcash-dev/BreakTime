{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport 'abort-controller/polyfill';\nimport { UnavailabilityError } from '@unimodules/core';\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport { addPushTokenListener } from \"./TokenEmitter\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from \"./utils/updateDevicePushTokenAsync\";\nvar lastAbortController = null;\n\nfunction updatePushTokenAsync(token) {\n  var _lastAbortController;\n\n  return _regeneratorRuntime.async(function updatePushTokenAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          (_lastAbortController = lastAbortController) == null ? void 0 : _lastAbortController.abort();\n          lastAbortController = new AbortController();\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token));\n\n        case 4:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexport function setAutoServerRegistrationEnabledAsync(enabled) {\n  var _lastAbortController2;\n\n  return _regeneratorRuntime.async(function setAutoServerRegistrationEnabledAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          (_lastAbortController2 = lastAbortController) == null ? void 0 : _lastAbortController2.abort();\n\n          if (ServerRegistrationModule.setRegistrationInfoAsync) {\n            _context2.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n\n        case 3:\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(ServerRegistrationModule.setRegistrationInfoAsync(enabled ? JSON.stringify({\n            isEnabled: enabled\n          }) : null));\n\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function __handlePersistedRegistrationInfoAsync(registrationInfo) {\n  var _registration;\n\n  var registration, latestDevicePushToken;\n  return _regeneratorRuntime.async(function __handlePersistedRegistrationInfoAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (registrationInfo) {\n            _context3.next = 2;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 2:\n          registration = null;\n\n          try {\n            registration = JSON.parse(registrationInfo);\n          } catch (e) {\n            console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.', e);\n          }\n\n          if ((_registration = registration) != null && _registration.isEnabled) {\n            _context3.next = 6;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 6:\n          _context3.prev = 6;\n          _context3.next = 9;\n          return _regeneratorRuntime.awrap(getDevicePushTokenAsync());\n\n        case 9:\n          latestDevicePushToken = _context3.sent;\n          _context3.next = 12;\n          return _regeneratorRuntime.awrap(updatePushTokenAsync(latestDevicePushToken));\n\n        case 12:\n          _context3.next = 17;\n          break;\n\n        case 14:\n          _context3.prev = 14;\n          _context3.t0 = _context3[\"catch\"](6);\n          console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', _context3.t0);\n\n        case 17:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[6, 14]], Promise);\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  addPushTokenListener(function _callee(token) {\n    var registrationInfo, registration;\n    return _regeneratorRuntime.async(function _callee$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return _regeneratorRuntime.awrap(ServerRegistrationModule.getRegistrationInfoAsync());\n\n          case 3:\n            registrationInfo = _context4.sent;\n\n            if (registrationInfo) {\n              _context4.next = 6;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 6:\n            registration = JSON.parse(registrationInfo);\n\n            if (!(registration != null && registration.isEnabled)) {\n              _context4.next = 10;\n              break;\n            }\n\n            _context4.next = 10;\n            return _regeneratorRuntime.awrap(updatePushTokenAsync(token));\n\n          case 10:\n            _context4.next = 15;\n            break;\n\n          case 12:\n            _context4.prev = 12;\n            _context4.t0 = _context4[\"catch\"](0);\n            console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', _context4.t0);\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, [[0, 12]], Promise);\n  });\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\", new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync'));\n}","map":{"version":3,"sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":";AAAA,OAAO,2BAAP;AACA,SAAS,mBAAT,QAAoC,kBAApC;AAEA,OAAO,wBAAP;AACA,SAAS,oBAAT;AAEA,OAAO,uBAAP;AACA,SAAS,0BAA0B,IAAI,oCAAvC;AAEA,IAAI,mBAAmB,GAA2B,IAAlD;;AACA,SAAe,oBAAf,CAAoC,KAApC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEE,kCAAA,mBAAmB,SAAnB,iCAAqB,KAArB;AACA,UAAA,mBAAmB,GAAG,IAAI,eAAJ,EAAtB;AAHF;AAAA,2CAIe,oCAAoC,CAAC,mBAAmB,CAAC,MAArB,EAA6B,KAA7B,CAJnD;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmBA,OAAO,SAAe,qCAAf,CAAqD,OAArD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAGL,mCAAA,mBAAmB,SAAnB,kCAAqB,KAArB;;AAHK,cAKA,wBAAwB,CAAC,wBALzB;AAAA;AAAA;AAAA;;AAAA,gBAMG,IAAI,mBAAJ,CAAwB,0BAAxB,EAAoD,0BAApD,CANH;;AAAA;AAAA;AAAA,2CASC,wBAAwB,CAAC,wBAAzB,CACJ,OAAO,GAAG,IAAI,CAAC,SAAL,CAAe;AAAE,YAAA,SAAS,EAAE;AAAb,WAAf,CAAH,GAA4C,IAD/C,CATD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBP,OAAO,SAAe,sCAAf,CACL,gBADK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAGA,gBAHA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAQD,UAAA,YARC,GAQkD,IARlD;;AASL,cAAI;AACF,YAAA,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,gBAAX,CAAf;AACD,WAFD,CAEE,OAAO,CAAP,EAAU;AACV,YAAA,OAAO,CAAC,IAAR,CACE,wGADF,EAEE,CAFF;AAID;;AAhBI,+BAkBA,YAlBA,aAkBA,cAAc,SAlBd;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA,2CA0BiC,uBAAuB,EA1BxD;;AAAA;AA0BG,UAAA,qBA1BH;AAAA;AAAA,2CA2BG,oBAAoB,CAAC,qBAAD,CA3BvB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA6BH,UAAA,OAAO,CAAC,IAAR,CACE,0GADF;;AA7BG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoCP,IAAI,wBAAwB,CAAC,wBAA7B,EAAuD;AAGrD,EAAA,oBAAoB,CAAC,iBAAM,KAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAKc,wBAAwB,CAAC,wBAAzB,EALd;;AAAA;AAKX,YAAA,gBALW;;AAAA,gBAOZ,gBAPY;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAYX,YAAA,YAZW,GAYwC,IAAI,CAAC,KAAL,CAAW,gBAAX,CAZxC;;AAAA,kBAab,YAba,YAab,YAAY,CAAE,SAbD;AAAA;AAAA;AAAA;;AAAA;AAAA,6CAgBT,oBAAoB,CAAC,KAAD,CAhBX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAmBjB,YAAA,OAAO,CAAC,IAAR,CACE,0GADF;;AAnBiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAD,CAApB;AA6BA,EAAA,wBAAwB,CAAC,wBAAzB,GAAoD,IAApD,CAAyD,sCAAzD;AACD,CAjCD,MAiCO;AACL,EAAA,OAAO,CAAC,IAAR,8IAEE,IAAI,mBAAJ,CAAwB,0BAAxB,EAAoD,0BAApD,CAFF;AAID","sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from '@unimodules/core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async token => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}