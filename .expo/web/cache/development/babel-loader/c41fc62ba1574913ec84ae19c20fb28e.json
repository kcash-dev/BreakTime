{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { computeNextBackoffInterval } from '@ide/backoff';\nimport { CodedError, Platform, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\nimport ServerRegistrationModule from \"../ServerRegistrationModule\";\nvar updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\nexport function updateDevicePushTokenAsync(signal, token) {\n  var doUpdateDevicePushTokenAsync, shouldTry, retry, retriesCount, initialBackoff, backoffOptions, nextBackoffInterval;\n  return _regeneratorRuntime.async(function updateDevicePushTokenAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          doUpdateDevicePushTokenAsync = function doUpdateDevicePushTokenAsync(retry) {\n            var _await$Promise$all, _await$Promise$all2, development, deviceId, body, response;\n\n            return _regeneratorRuntime.async(function doUpdateDevicePushTokenAsync$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return _regeneratorRuntime.awrap(Promise.all([shouldUseDevelopmentNotificationService(), getDeviceIdAsync()]));\n\n                  case 2:\n                    _await$Promise$all = _context.sent;\n                    _await$Promise$all2 = _slicedToArray(_await$Promise$all, 2);\n                    development = _await$Promise$all2[0];\n                    deviceId = _await$Promise$all2[1];\n                    body = {\n                      deviceId: deviceId,\n                      development: development,\n                      deviceToken: token.data,\n                      appId: Application.applicationId,\n                      type: getTypeOfToken(token)\n                    };\n                    _context.prev = 7;\n                    _context.next = 10;\n                    return _regeneratorRuntime.awrap(fetch(updateDevicePushTokenUrl, {\n                      method: 'POST',\n                      headers: {\n                        'content-type': 'application/json'\n                      },\n                      body: JSON.stringify(body),\n                      signal: signal\n                    }));\n\n                  case 10:\n                    response = _context.sent;\n\n                    if (response.ok) {\n                      _context.next = 17;\n                      break;\n                    }\n\n                    _context.t0 = console;\n                    _context.next = 15;\n                    return _regeneratorRuntime.awrap(response.text());\n\n                  case 15:\n                    _context.t1 = _context.sent;\n\n                    _context.t0.debug.call(_context.t0, '[expo-notifications] Error encountered while updating the device push token with the server:', _context.t1);\n\n                  case 17:\n                    if (!response.ok) {\n                      retry();\n                    }\n\n                    _context.next = 26;\n                    break;\n\n                  case 20:\n                    _context.prev = 20;\n                    _context.t2 = _context[\"catch\"](7);\n\n                    if (!(_context.t2.name === 'AbortError')) {\n                      _context.next = 24;\n                      break;\n                    }\n\n                    return _context.abrupt(\"return\");\n\n                  case 24:\n                    console.warn('[expo-notifications] Error thrown while updating the device push token with the server:', _context.t2);\n                    retry();\n\n                  case 26:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, null, null, [[7, 20]], Promise);\n          };\n\n          shouldTry = true;\n\n          retry = function retry() {\n            shouldTry = true;\n          };\n\n          retriesCount = 0;\n          initialBackoff = 500;\n          backoffOptions = {\n            maxBackoff: 2 * 60 * 1000\n          };\n          nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n\n        case 7:\n          if (!(shouldTry && !signal.aborted)) {\n            _context2.next = 18;\n            break;\n          }\n\n          shouldTry = false;\n          _context2.next = 11;\n          return _regeneratorRuntime.awrap(doUpdateDevicePushTokenAsync(retry));\n\n        case 11:\n          if (!(shouldTry && !signal.aborted)) {\n            _context2.next = 16;\n            break;\n          }\n\n          nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n          retriesCount += 1;\n          _context2.next = 16;\n          return _regeneratorRuntime.awrap(new Promise(function (resolve) {\n            return setTimeout(resolve, nextBackoffInterval);\n          }));\n\n        case 16:\n          _context2.next = 7;\n          break;\n\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction getDeviceIdAsync() {\n  return _regeneratorRuntime.async(function getDeviceIdAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n\n          if (ServerRegistrationModule.getInstallationIdAsync) {\n            _context3.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n\n        case 3:\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(ServerRegistrationModule.getInstallationIdAsync());\n\n        case 5:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 8:\n          _context3.prev = 8;\n          _context3.t0 = _context3[\"catch\"](0);\n          throw new CodedError('ERR_NOTIFICATIONS_DEVICE_ID', \"Could not fetch the installation ID of the application: \" + _context3.t0 + \".\");\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n}\n\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n\n    case 'android':\n      return 'fcm';\n\n    default:\n      return devicePushToken.type;\n  }\n}\n\nfunction shouldUseDevelopmentNotificationService() {\n  var notificationServiceEnvironment;\n  return _regeneratorRuntime.async(function shouldUseDevelopmentNotificationService$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (!(Platform.OS === 'ios')) {\n            _context4.next = 11;\n            break;\n          }\n\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());\n\n        case 4:\n          notificationServiceEnvironment = _context4.sent;\n\n          if (!(notificationServiceEnvironment === 'development')) {\n            _context4.next = 7;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", true);\n\n        case 7:\n          _context4.next = 11;\n          break;\n\n        case 9:\n          _context4.prev = 9;\n          _context4.t0 = _context4[\"catch\"](1);\n\n        case 11:\n          return _context4.abrupt(\"return\", false);\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 9]], Promise);\n}","map":{"version":3,"sources":["../../src/utils/updateDevicePushTokenAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { computeNextBackoffInterval } from '@ide/backoff';\nimport { CodedError, Platform, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\n\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\n\nconst updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\n\nexport async function updateDevicePushTokenAsync(signal: AbortSignal, token: DevicePushToken) {\n  const doUpdateDevicePushTokenAsync = async (retry: () => void) => {\n    const [development, deviceId] = await Promise.all([\n      shouldUseDevelopmentNotificationService(),\n      getDeviceIdAsync(),\n    ]);\n    const body = {\n      deviceId,\n      development,\n      deviceToken: token.data,\n      appId: Application.applicationId,\n      type: getTypeOfToken(token),\n    };\n\n    try {\n      const response = await fetch(updateDevicePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating the device push token with the server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (e) {\n      // Error returned if the request is aborted should be an 'AbortError'. In\n      // React Native fetch is polyfilled using `whatwg-fetch` which:\n      // - creates `AbortError`s like this\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L505\n      // - which creates exceptions like\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L490-L494\n      if (e.name === 'AbortError') {\n        // We don't consider AbortError a failure, it's a sign somewhere else the\n        // request is expected to succeed and we don't need this one, so let's\n        // just return.\n        return;\n      }\n\n      console.warn(\n        '[expo-notifications] Error thrown while updating the device push token with the server:',\n        e\n      );\n\n      retry();\n    }\n  };\n\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n\n  let retriesCount = 0;\n  const initialBackoff = 500; // 0.5 s\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000, // 2 minutes\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(\n    initialBackoff,\n    retriesCount,\n    backoffOptions\n  );\n\n  while (shouldTry && !signal.aborted) {\n    // Will be set to true by `retry` if it's called\n    shouldTry = false;\n    await doUpdateDevicePushTokenAsync(retry);\n\n    // Do not wait if we won't retry\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(\n        initialBackoff,\n        retriesCount,\n        backoffOptions\n      );\n      retriesCount += 1;\n      await new Promise(resolve => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_DEVICE_ID',\n      `Could not fetch the installation ID of the application: ${e}.`\n    );\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}