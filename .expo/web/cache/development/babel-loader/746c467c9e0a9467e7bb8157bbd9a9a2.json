{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { Platform, CodedError, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { setAutoServerRegistrationEnabledAsync } from \"./DevicePushTokenAutoRegistration.fx\";\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nvar productionBaseUrl = 'https://exp.host/--/api/v2/';\nexport default function getExpoPushTokenAsync() {\n  var _Constants$manifest, _Constants$manifest2, _options$baseUrl, _options$url;\n\n  var options,\n      devicePushToken,\n      deviceId,\n      experienceId,\n      applicationId,\n      type,\n      development,\n      baseUrl,\n      url,\n      body,\n      response,\n      statusInfo,\n      _body,\n      expoPushToken,\n      _args = arguments;\n\n  return _regeneratorRuntime.async(function getExpoPushTokenAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n          _context.t0 = options.devicePushToken;\n\n          if (_context.t0) {\n            _context.next = 6;\n            break;\n          }\n\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(getDevicePushTokenAsync());\n\n        case 5:\n          _context.t0 = _context.sent;\n\n        case 6:\n          devicePushToken = _context.t0;\n          _context.t1 = options.deviceId;\n\n          if (_context.t1) {\n            _context.next = 12;\n            break;\n          }\n\n          _context.next = 11;\n          return _regeneratorRuntime.awrap(getDeviceIdAsync());\n\n        case 11:\n          _context.t1 = _context.sent;\n\n        case 12:\n          deviceId = _context.t1;\n          experienceId = options.experienceId || ((_Constants$manifest = Constants.manifest) == null ? void 0 : _Constants$manifest.originalFullName) || ((_Constants$manifest2 = Constants.manifest) == null ? void 0 : _Constants$manifest2.id);\n\n          if (experienceId) {\n            _context.next = 16;\n            break;\n          }\n\n          throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID', \"No experienceId found. If it can't be inferred from the manifest (eg. in bare workflow), you have to pass it in yourself.\");\n\n        case 16:\n          applicationId = options.applicationId || Application.applicationId;\n\n          if (applicationId) {\n            _context.next = 19;\n            break;\n          }\n\n          throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID', \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");\n\n        case 19:\n          type = options.type || getTypeOfToken(devicePushToken);\n          _context.t2 = options.development;\n\n          if (_context.t2) {\n            _context.next = 25;\n            break;\n          }\n\n          _context.next = 24;\n          return _regeneratorRuntime.awrap(shouldUseDevelopmentNotificationService());\n\n        case 24:\n          _context.t2 = _context.sent;\n\n        case 25:\n          development = _context.t2;\n          baseUrl = (_options$baseUrl = options.baseUrl) != null ? _options$baseUrl : productionBaseUrl;\n          url = (_options$url = options.url) != null ? _options$url : baseUrl + \"push/getExpoPushToken\";\n          body = {\n            type: type,\n            deviceId: deviceId,\n            development: development,\n            experienceId: experienceId,\n            appId: applicationId,\n            deviceToken: getDeviceToken(devicePushToken)\n          };\n          _context.next = 31;\n          return _regeneratorRuntime.awrap(fetch(url, {\n            method: 'POST',\n            headers: {\n              'content-type': 'application/json'\n            },\n            body: JSON.stringify(body)\n          }).catch(function (error) {\n            throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR', \"Error encountered while fetching Expo token: \" + error + \".\");\n          }));\n\n        case 31:\n          response = _context.sent;\n\n          if (response.ok) {\n            _context.next = 44;\n            break;\n          }\n\n          statusInfo = response.statusText || response.status;\n          _body = undefined;\n          _context.prev = 35;\n          _context.next = 38;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 38:\n          _body = _context.sent;\n          _context.next = 43;\n          break;\n\n        case 41:\n          _context.prev = 41;\n          _context.t3 = _context[\"catch\"](35);\n\n        case 43:\n          throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Error encountered while fetching Expo token, expected an OK response, received: \" + statusInfo + \" (body: \\\"\" + _body + \"\\\").\");\n\n        case 44:\n          _context.t4 = getExpoPushToken;\n          _context.next = 47;\n          return _regeneratorRuntime.awrap(parseResponse(response));\n\n        case 47:\n          _context.t5 = _context.sent;\n          expoPushToken = (0, _context.t4)(_context.t5);\n          _context.prev = 49;\n\n          if (!(options.url || options.baseUrl)) {\n            _context.next = 54;\n            break;\n          }\n\n          console.debug(\"[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.\");\n          _context.next = 56;\n          break;\n\n        case 54:\n          _context.next = 56;\n          return _regeneratorRuntime.awrap(setAutoServerRegistrationEnabledAsync(true));\n\n        case 56:\n          _context.next = 61;\n          break;\n\n        case 58:\n          _context.prev = 58;\n          _context.t6 = _context[\"catch\"](49);\n          console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service', _context.t6);\n\n        case 61:\n          return _context.abrupt(\"return\", {\n            type: 'expo',\n            data: expoPushToken\n          });\n\n        case 62:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[35, 41], [49, 58]], Promise);\n}\n\nfunction parseResponse(response) {\n  return _regeneratorRuntime.async(function parseResponse$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(response.json());\n\n        case 3:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 6:\n          _context2.prev = 6;\n          _context2.t0 = _context2[\"catch\"](0);\n          _context2.prev = 8;\n          _context2.t1 = CodedError;\n          _context2.t2 = JSON;\n          _context2.next = 13;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 13:\n          _context2.t3 = _context2.sent;\n          _context2.t4 = _context2.t2.stringify.call(_context2.t2, _context2.t3);\n          _context2.t5 = \"Expected a JSON response from server when fetching Expo token, received body: \" + _context2.t4;\n          _context2.t6 = _context2.t5 + \".\";\n          throw new _context2.t1('ERR_NOTIFICATIONS_SERVER_ERROR', _context2.t6);\n\n        case 20:\n          _context2.prev = 20;\n          _context2.t7 = _context2[\"catch\"](8);\n          throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Expected a JSON response from server when fetching Expo token, received response: \" + JSON.stringify(response) + \".\");\n\n        case 23:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[0, 6], [8, 20]], Promise);\n}\n\nfunction getExpoPushToken(data) {\n  if (!data || !(typeof data === 'object') || !data.data || !(typeof data.data === 'object') || !data.data.expoPushToken || !(typeof data.data.expoPushToken === 'string')) {\n    throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Malformed response from server, expected \\\"{ data: { expoPushToken: string } }\\\", received: \" + JSON.stringify(data, null, 2) + \".\");\n  }\n\n  return data.data.expoPushToken;\n}\n\nfunction getDeviceIdAsync() {\n  return _regeneratorRuntime.async(function getDeviceIdAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n\n          if (ServerRegistrationModule.getInstallationIdAsync) {\n            _context3.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n\n        case 3:\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(ServerRegistrationModule.getInstallationIdAsync());\n\n        case 5:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 8:\n          _context3.prev = 8;\n          _context3.t0 = _context3[\"catch\"](0);\n          throw new CodedError('ERR_NOTIF_DEVICE_ID', \"Could not have fetched installation ID of the application: \" + _context3.t0 + \".\");\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n}\n\nfunction getDeviceToken(devicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\nfunction shouldUseDevelopmentNotificationService() {\n  var notificationServiceEnvironment;\n  return _regeneratorRuntime.async(function shouldUseDevelopmentNotificationService$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (!(Platform.OS === 'ios')) {\n            _context4.next = 11;\n            break;\n          }\n\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());\n\n        case 4:\n          notificationServiceEnvironment = _context4.sent;\n\n          if (!(notificationServiceEnvironment === 'development')) {\n            _context4.next = 7;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", true);\n\n        case 7:\n          _context4.next = 11;\n          break;\n\n        case 9:\n          _context4.prev = 9;\n          _context4.t0 = _context4[\"catch\"](1);\n\n        case 11:\n          return _context4.abrupt(\"return\", false);\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 9]], Promise);\n}\n\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n\n    case 'android':\n      return 'fcm';\n\n    default:\n      return devicePushToken.type;\n  }\n}","map":{"version":3,"sources":["../src/getExpoPushTokenAsync.ts"],"names":[],"mappings":";AAAA,SAAS,QAAT,EAAmB,UAAnB,EAA+B,mBAA/B,QAA0D,kBAA1D;AACA,OAAO,KAAK,WAAZ,MAA6B,kBAA7B;AACA,OAAO,SAAP,MAAsB,gBAAtB;AAEA,SAAS,qCAAT;AACA,OAAO,wBAAP;AAEA,OAAO,uBAAP;AAEA,IAAM,iBAAiB,GAAG,6BAA1B;AAkBA,eAAe,SAAe,qBAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAqC,UAAA,OAArC,2DAAwD,EAAxD;AAAA,wBACW,OAAO,CAAC,eADnB;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAC6C,uBAAuB,EADpE;;AAAA;AAAA;;AAAA;AACP,UAAA,eADO;AAAA,wBAGI,OAAO,CAAC,QAHZ;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAG+B,gBAAgB,EAH/C;;AAAA;AAAA;;AAAA;AAGP,UAAA,QAHO;AAKP,UAAA,YALO,GAMX,OAAO,CAAC,YAAR,4BAAwB,SAAS,CAAC,QAAlC,qBAAwB,oBAAoB,gBAA5C,8BAAgE,SAAS,CAAC,QAA1E,qBAAgE,qBAAoB,EAApF,CANW;;AAAA,cAQR,YARQ;AAAA;AAAA;AAAA;;AAAA,gBASL,IAAI,UAAJ,CACJ,oCADI,EAEJ,2HAFI,CATK;;AAAA;AAeP,UAAA,aAfO,GAeS,OAAO,CAAC,aAAR,IAAyB,WAAW,CAAC,aAf9C;;AAAA,cAgBR,aAhBQ;AAAA;AAAA;AAAA;;AAAA,gBAiBL,IAAI,UAAJ,CACJ,qCADI,EAEJ,iIAFI,CAjBK;;AAAA;AAsBP,UAAA,IAtBO,GAsBA,OAAO,CAAC,IAAR,IAAgB,cAAc,CAAC,eAAD,CAtB9B;AAAA,wBAuBO,OAAO,CAAC,WAvBf;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAuBqC,uCAAuC,EAvB5E;;AAAA;AAAA;;AAAA;AAuBP,UAAA,WAvBO;AAyBP,UAAA,OAzBO,uBAyBG,OAAO,CAAC,OAzBX,+BAyBsB,iBAzBtB;AA0BP,UAAA,GA1BO,mBA0BD,OAAO,CAAC,GA1BP,2BA0BiB,OA1BjB;AA4BP,UAAA,IA5BO,GA4BA;AACX,YAAA,IAAI,EAAJ,IADW;AAEX,YAAA,QAAQ,EAAR,QAFW;AAGX,YAAA,WAAW,EAAX,WAHW;AAIX,YAAA,YAAY,EAAZ,YAJW;AAKX,YAAA,KAAK,EAAE,aALI;AAMX,YAAA,WAAW,EAAE,cAAc,CAAC,eAAD;AANhB,WA5BA;AAAA;AAAA,2CAqCU,KAAK,CAAC,GAAD,EAAM;AAChC,YAAA,MAAM,EAAE,MADwB;AAEhC,YAAA,OAAO,EAAE;AACP,8BAAgB;AADT,aAFuB;AAKhC,YAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,IAAf;AAL0B,WAAN,CAAL,CAMpB,KANoB,CAMd,UAAA,KAAK,EAAG;AACf,kBAAM,IAAI,UAAJ,CACJ,iCADI,oDAE4C,KAF5C,OAAN;AAID,WAXsB,CArCV;;AAAA;AAqCP,UAAA,QArCO;;AAAA,cAkDR,QAAQ,CAAC,EAlDD;AAAA;AAAA;AAAA;;AAmDL,UAAA,UAnDK,GAmDQ,QAAQ,CAAC,UAAT,IAAuB,QAAQ,CAAC,MAnDxC;AAoDP,UAAA,KApDO,GAoDoB,SApDpB;AAAA;AAAA;AAAA,2CAsDI,QAAQ,CAAC,IAAT,EAtDJ;;AAAA;AAsDT,UAAA,KAtDS;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,gBA0DL,IAAI,UAAJ,CACJ,gCADI,uFAE+E,UAF/E,kBAEqG,KAFrG,UA1DK;;AAAA;AAAA,wBAgES,gBAhET;AAAA;AAAA,2CAgEgC,aAAa,CAAC,QAAD,CAhE7C;;AAAA;AAAA;AAgEP,UAAA,aAhEO;AAAA;;AAAA,gBAmEP,OAAO,CAAC,GAAR,IAAe,OAAO,CAAC,OAnEhB;AAAA;AAAA;AAAA;;AAoET,UAAA,OAAO,CAAC,KAAR;AApES;AAAA;;AAAA;AAAA;AAAA,2CAwEH,qCAAqC,CAAC,IAAD,CAxElC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA2EX,UAAA,OAAO,CAAC,IAAR,CACE,sHADF;;AA3EW;AAAA,2CAiFN;AACL,YAAA,IAAI,EAAE,MADD;AAEL,YAAA,IAAI,EAAE;AAFD,WAjFM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuFf,SAAe,aAAf,CAA6B,QAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CAEiB,QAAQ,CAAC,IAAT,EAFjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,yBAKgB,UALhB;AAAA,yBAOyF,IAPzF;AAAA;AAAA,2CAQgB,QAAQ,CAAC,IAAT,EARhB;;AAAA;AAAA;AAAA,sCAO8F,SAP9F;AAAA;AAAA;AAAA,iCAMQ,gCANR;;AAAA;AAAA;AAAA;AAAA,gBAYY,IAAI,UAAJ,CACJ,gCADI,yFAEiF,IAAI,CAAC,SAAL,CACnF,QADmF,CAFjF,OAZZ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsBA,SAAS,gBAAT,CAA0B,IAA1B,EAAmC;AACjC,MACE,CAAC,IAAD,IACA,EAAE,OAAO,IAAP,KAAgB,QAAlB,CADA,IAEA,CAAC,IAAI,CAAC,IAFN,IAGA,EAAE,OAAO,IAAI,CAAC,IAAZ,KAAqB,QAAvB,CAHA,IAIA,CAAC,IAAI,CAAC,IAAL,CAAU,aAJX,IAKA,EAAE,OAAO,IAAI,CAAC,IAAL,CAAU,aAAjB,KAAmC,QAArC,CANF,EAOE;AACA,UAAM,IAAI,UAAJ,CACJ,gCADI,mGAEyF,IAAI,CAAC,SAAL,CAC3F,IAD2F,EAE3F,IAF2F,EAG3F,CAH2F,CAFzF,OAAN;AAQD;;AAED,SAAO,IAAI,CAAC,IAAL,CAAU,aAAjB;AACD;;AAGD,SAAe,gBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,cAES,wBAAwB,CAAC,sBAFlC;AAAA;AAAA;AAAA;;AAAA,gBAGY,IAAI,mBAAJ,CAAwB,8BAAxB,EAAwD,wBAAxD,CAHZ;;AAAA;AAAA;AAAA,2CAMiB,wBAAwB,CAAC,sBAAzB,EANjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,gBAQU,IAAI,UAAJ,CACJ,qBADI,qFARV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA,SAAS,cAAT,CAAwB,eAAxB,EAAwD;AACtD,MAAI,OAAO,eAAe,CAAC,IAAvB,KAAgC,QAApC,EAA8C;AAC5C,WAAO,eAAe,CAAC,IAAvB;AACD;;AAED,SAAO,IAAI,CAAC,SAAL,CAAe,eAAe,CAAC,IAA/B,CAAP;AACD;;AAGD,SAAe,uCAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBACM,QAAQ,CAAC,EAAT,KAAgB,KADtB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,2CAGmD,WAAW,CAAC,6CAAZ,EAHnD;;AAAA;AAGY,UAAA,8BAHZ;;AAAA,gBAIU,8BAA8B,KAAK,aAJ7C;AAAA;AAAA;AAAA;;AAAA,4CAKe,IALf;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,4CAYS,KAZT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA,SAAS,cAAT,CAAwB,eAAxB,EAAwD;AACtD,UAAQ,eAAe,CAAC,IAAxB;AACE,SAAK,KAAL;AACE,aAAO,MAAP;;AACF,SAAK,SAAL;AACE,aAAO,KAAP;;AAEF;AACE,aAAO,eAAe,CAAC,IAAvB;AAPJ;AASD","sourcesContent":["import { Platform, CodedError, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\nimport Constants from 'expo-constants';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\ninterface Options {\n  // Endpoint URL override\n  baseUrl?: string;\n\n  // Request URL override\n  url?: string;\n\n  // Request body overrides\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  applicationId?: string;\n  devicePushToken?: DevicePushToken;\n}\n\nexport default async function getExpoPushTokenAsync(options: Options = {}): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n\n  const experienceId =\n    options.experienceId || Constants.manifest?.originalFullName || Constants.manifest?.id;\n\n  if (!experienceId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No experienceId found. If it can't be inferred from the manifest (eg. in bare workflow), you have to pass it in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId,\n    development,\n    experienceId,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch(error => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch (error) {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch (error) {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch (innerError) {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}